import fs from 'fs';

/**
 * @typedef {import('esbuild').BuildOptions} BuildOptions
 */

/** @returns {BuildOptions} */
export function generate_worker({ app_js_path, worker_path, assets_prefix, scheduled_route }) {
	const entry_point = worker_path + '/entry.js';
	// prettier-ignore
	fs.writeFileSync( worker_path + '/package.json', `
			{
				"private": true,
				"version": "0.0.1",
				"description": "Worker site generated by SvelteKit",
				"main": "index.js",
				"dependencies": {
					"@cloudflare/kv-asset-handler": "~0.0.11"
				}
			}`
			.replace(/^\t{3}/gm, '')
			.trim());

	// prettier-ignore
	fs.writeFileSync( entry_point, `
			import { init, render } from '${app_js_path}';
			import { getAssetFromKV, NotFoundError, mapRequestToAsset } from '@cloudflare/kv-asset-handler';

			init();

			addEventListener('fetch', (event) => {
				event.respondWith(handle(event));
			});

			async function handle(event) {
				// try static assets first
				if (event.request.method == 'GET') {
					try {
						// TODO rather than attempting to get an asset,
						// use the asset manifest to see if it exists
						return await getAssetFromKV(event, ${ assets_prefix ? `{
							mapRequestToAsset: (request) => {
								return mapRequestToAsset(
									new Request(request.url.replace(/^([^:]+:\\/\\/[^/]+)(\\/.*)/, '$1${assets_prefix}$2'), request)
								);
							}
						}` : '{}'});
					} catch (e) {
						if (!(e instanceof NotFoundError)) {
							return new Response('Error loading static asset: '+ (e.message || e.toString()) +'.', {
								status: 500
							});
						}
					}
				}

				// fall back to an app route
				const request = event.request;
				const request_url = new URL(request.url);

				try {
					const rendered = await render({
						host: request_url.host,
						path: request_url.pathname,
						query: request_url.searchParams,
						rawBody: await read(request),
						headers: Object.fromEntries(request.headers),
						method: request.method
					});

					if (rendered) {
						return new Response(rendered.body, {
							status: rendered.status,
							headers: makeHeaders(rendered.headers)
						});
					}
				} catch (e) {
					return new Response('Error rendering route:' + (e.message || e.toString()), { status: 500 });
				}

				return new Response({
					status: 404,
					statusText: 'Not Found'
				});
			}

			/** @param {Request} request */
			async function read(request) {
				return new Uint8Array(await request.arrayBuffer());
			}

			/**
			 * @param {Record<string, string | string[]>} headers
			 * @returns {Request}
			 */
			function makeHeaders(headers) {
				const result = new Headers();
				for (const header in headers) {
					const value = headers[header];
					if (typeof value === 'string') {
						result.set(header, value);
						continue;
					}
					for (const sub of value) {
						result.append(header, sub);
					}
				}
				return result;
			}

			${ scheduled_route ? `addEventListener('scheduled', (event) => {
				event.waitUntil(handleScheduled(event));
			});

			async function handleScheduled(event) {
				return handle({
					...event,
					request: new Request('${scheduled_route}')
				});
			}` : ''}
			`
			.replace(/^\t{3}/gm, '')
			.trim());

	return {
		entryPoints: [entry_point],
		bundle: true,
		target: 'es2020',
		platform: 'browser'
	};
}
